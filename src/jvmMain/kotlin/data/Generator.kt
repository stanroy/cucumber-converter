package data

import common.capitalizeIt
import common.printIt
import java.io.File
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.time.format.FormatStyle

class Generator {

    private fun version(): String? {
        val buildGradle = File("build.gradle.kts")

        val regex = Regex("""version\s*=\s*["'](.+?)["']""")
        val matchResult = regex.find(buildGradle.readText())

        return matchResult?.groupValues?.getOrNull(1)
    }

    private fun timeStamp(): String? {
        val now = LocalDateTime.now()
        val formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM)

        return now.format(formatter)
    }

    private fun splitScenarios(scenarioFileContents: String): Map<String, Map<String, List<String>>> {
        // Split the scenario file contents into lines and perform initial filtering
        val scenarioFileLines =
            scenarioFileContents.lines().filter { it.isNotBlank() }.filterNot { it.lowercase().contains("feature") }
                .map { it.trimStart() }

        // Create a map to store the scenarios and their steps with data tables
        val scenarioMap = mutableMapOf<String, MutableMap<String, MutableList<String>>>()
        var currentStep: String? = null

        // Go over each line in the scenario file
        scenarioFileLines.forEach { line ->
            when {
                line.startsWith("Scenario:") -> {
                    // If line starts with "Scenario:", it indicates a new scenario
                    // Create a new map to store the steps and data tables of the current scenario
                    scenarioMap[line] = mutableMapOf()
                    currentStep = null
                }

                line.startsWith("|") -> {
                    // If line starts with "|", it indicates a data table row
                    if (currentStep != null) {
                        // Add the data table row to the current step in the scenario map
                        scenarioMap.values.lastOrNull()?.get(currentStep!!)?.add(line)
                    }
                }

                line.isBlank() -> {
                    // If line is blank, it indicates the end of a step or data table
                    currentStep = null
                }

                line.startsWith("#") -> {
                    // line starts with a #, it indicates that this line is a comment
                    currentStep = null
                }

                else -> {
                    // Otherwise, it's a regular step line
                    currentStep = line
                    // Create a new list to store the data tables of the current step
                    scenarioMap.values.lastOrNull()?.set(currentStep!!, mutableListOf())
                }
            }
        }

        return scenarioMap
    }

    fun createSwiftFunctions(scenarioFile: ScenarioFile) {
        val scenariosMap = splitScenarios(scenarioFile.fileContents)

        fun insertFunctions(): String {

            val functions = StringBuilder()

            functions.appendLine("//")
            functions.appendLine("//  ${scenarioFile.fileName}.swift")
            functions.appendLine("//  Generated by: Cucumber Converter ${version()}")
            functions.appendLine("//  Generated on: ${timeStamp()}")
            functions.appendLine("//")
            functions.appendLine()
            functions.appendLine("import XCTEST")
            functions.appendLine()
            functions.appendLine("class ${scenarioFile.fileName.capitalizeIt()}: XCTestCase {")
            functions.appendLine("    let app = XCUIApplication()")
            functions.appendLine()
            scenariosMap.forEach { (scenario, stepMap) ->
                val scenarioName = formatScenarioFunction(scenario, stepMap)
                functions.appendLine(scenarioName)
            }
            functions.appendLine("}")

            return functions.toString()
        }

        val testFile = insertFunctions()

        testFile.printIt()

    }

    private fun formatStepFunction(step: String, dataTable: List<String>): String {
        val stepFunctionBuilder = StringBuilder()
        val stepInitialFormatting = step.lowercase().filterNot { it == '\'' }.filterNot { it == '-' }.replace(' ', '_')
        val regex = "\"([^\"]+)\"".toRegex()
        val extractedValues = regex.findAll(step).map { it.groupValues[1] }.toList()
        val formattedStepParameters = extractedValues.joinToString(",") { "\"$it\"" }
        val parametersSection =
            if (formattedStepParameters.isNotEmpty()) "parameters: [$formattedStepParameters]" else ""
        val stepName = stepInitialFormatting.replace(regex, "").replace("_+".toRegex(), "_").dropLastWhile { it == '_' }
        val stepFunctionSignature = "try $stepName($parametersSection) {"

        stepFunctionBuilder.apply {
            appendLine("        $stepFunctionSignature")
            appendLine()
            appendLine("        }")
        }

        return stepFunctionBuilder.toString()
    }


    private fun formatScenarioFunction(scenario: String, stepMap: Map<String, List<String>>): String {
        val scenarioFunctionBuilder = StringBuilder()
        val scenarioName = scenario.substringAfter(':').trimStart().lowercase()
            .filterNot { it == '\'' }.filterNot { it == '-' }.replace(' ', '_')

        val scenarioFunctionSignature = "func test_$scenarioName() throws {"

        scenarioFunctionBuilder.apply {
            appendLine("    $scenarioFunctionSignature")
            stepMap.forEach { (step, dataTable) ->
                appendLine(formatStepFunction(step, dataTable))
            }
            appendLine("    }")
            appendLine()
        }

        return scenarioFunctionBuilder.toString()
    }

}